value = 30, min = 10, max = 30000)),
wellPanel("Your approximation of pi is:",
verbatimTextOutput("pi"))) , width = 3, offset = 1),
column(
wellPanel(
plotOutput("plot", width = "775px", height = "775px"),
width = 6
)
)
)
)
ui <- fluidPage( theme = shinytheme("flatly"),
fluidRow( column (verticalLayout(
wellPanel("We will aproximate Pi by generating random points
in a square and then counting what fraction of those
points are inside the circle contained in the square.
You can think of this as randomly throwing darts at a square board.
Since we know what the area of a square is we've
replaced a calculus problem with a counting problem! Play around with the slider on the
right - you should get a beter approximation of Pi the more points you use."),
wellPanel(sliderInput(inputId = "num",
label = "Number of Points",
value = 30, min = 10, max = 30000)),
wellPanel("Your approximation of pi is:",
verbatimTextOutput("pi"))) , width = 3, offset = 1),
column(
wellPanel(
plotOutput("plot", width = "775px", height = "775px")),
width = 6)
)
)
shinyApp(ui = ui, server = server)
ui <- fluidPage( theme = shinytheme("flatly"),
fluidRow( column (verticalLayout(
wellPanel("We will aproximate Pi by generating random points
in a square and then counting what fraction of those
points are inside the circle contained in the square.
You can think of this as randomly throwing darts at a square board.
Since we know what the area of a square is we've
replaced a calculus problem with a counting problem! Play around with the slider on the
right - you should get a beter approximation of Pi the more points you use."),
wellPanel(sliderInput(inputId = "num",
label = "Number of Points",
value = 30, min = 10, max = 30000)),
wellPanel("Your approximation of pi is:",
verbatimTextOutput("pi"))) , width = 3, offset = 1),
column(
wellPanel(
plotOutput("plot", width = "775px", height = "775px")),
width = 8)
)
)
server <- function(input, output) {
dat <- function(num){
x <- replicate(2, runif(num ,min = -1, max = 1))
inside <- (apply(x, 1, function(x) {x[1]^2 +x[2]^2}))<=1
data.frame(x, inside)
}
rv <- reactive({dat(input$num)})
output$pi <- renderPrint({
4 *sum(rv()$inside)/input$num
})
output$plot <- renderPlot({
qplot(rv()[,1], rv()[,2], data = rv(),color = inside, xlab = "x", ylab = "y") +
#scale_colour_manual(values=c("#9999CC", "#66CC99")) +
scale_color_brewer(palette = "Set1") +
theme_minimal() +
theme(legend.position="none")
})
}
shinyApp(ui = ui, server = server)
library(ggplot2)
library(shiny)
library(shinythemes)
ui <- fluidPage( theme = shinytheme("flatly"),
fluidRow( column (verticalLayout(
wellPanel("We will aproximate Pi by generating random points
in a square and then counting what fraction of those
points are inside the circle contained in the square.
You can think of this as randomly throwing darts at a square board.
Since we know what the area of a square is we've
replaced a calculus problem with a counting problem! Play around with the slider on the
right - you should get a better approximation of Pi the more points you use."),
wellPanel(sliderInput(inputId = "num",
label = "Number of Points",
value = 30, min = 10, max = 30000)),
wellPanel("Your approximation of pi is:",
verbatimTextOutput("pi"))) , width = 3, offset = 1),
column(
wellPanel(
plotOutput("plot", width = "775px", height = "775px")),
width = 8)
)
)
server <- function(input, output) {
dat <- function(num){
x <- replicate(2, runif(num ,min = -1, max = 1))
inside <- (apply(x, 1, function(x) {x[1]^2 +x[2]^2}))<=1
data.frame(x, inside)
}
rv <- reactive({dat(input$num)})
output$pi <- renderPrint({
4 *sum(rv()$inside)/input$num
})
output$plot <- renderPlot({
qplot(rv()[,1], rv()[,2], data = rv(),color = inside, xlab = "x", ylab = "y") +
#scale_colour_manual(values=c("#9999CC", "#66CC99")) +
scale_color_brewer(palette = "Set1") +
theme_minimal() +
theme(legend.position="none")
})
}
shinyApp(ui = ui, server = server)
ui <- fluidPage( theme = shinytheme("flatly"),
fluidRow( column (verticalLayout(
helpText("We will aproximate Pi by generating random points
in a square and then counting what fraction of those
points are inside the circle contained in the square.
You can think of this as randomly throwing darts at a square board.
Since we know what the area of a square is we've
replaced a calculus problem with a counting problem! Play around with the slider on the
right - you should get a better approximation of Pi the more points you use."),
wellPanel(sliderInput(inputId = "num",
label = "Number of Points",
value = 100, min = 10, max = 30000)),
wellPanel("Your approximation of pi is:",
verbatimTextOutput("pi"))) , width = 3, offset = 1),
column(
wellPanel(
plotOutput("plot", width = "775px", height = "775px")),
width = 8)
)
)
server <- function(input, output) {
dat <- function(num){
x <- replicate(2, runif(num ,min = -1, max = 1))
inside <- (apply(x, 1, function(x) {x[1]^2 +x[2]^2}))<=1
data.frame(x, inside)
}
rv <- reactive({dat(input$num)})
output$pi <- renderPrint({
4 *sum(rv()$inside)/input$num
})
output$plot <- renderPlot({
qplot(rv()[,1], rv()[,2], data = rv(),color = inside, xlab = "x", ylab = "y") +
#scale_colour_manual(values=c("#9999CC", "#66CC99")) +
scale_color_brewer(palette = "Set1") +
theme_minimal() +
theme(legend.position="none")
})
}
shinyApp(ui = ui, server = server)
ui <- fluidPage( theme = shinytheme("flatly"),
fluidRow( column (verticalLayout(
helpText("We will aproximate Pi by generating random points
in a square and then counting what fraction of those
points are inside the circle contained in the square.
You can think of this as randomly throwing darts at a square board.
Since we know what the area of a square is we've
replaced a calculus problem with a counting problem! Play around with the slider on the
right - you should get a better approximation of Pi the more points you use."),
wellPanel(sliderInput(inputId = "num",
label = "Number of Points",
value = 100, min = 10, max = 30000)),
wellPanel("Your approximation of pi is:",
verbatimTextOutput("pi"))) , width = 3, offset = 1),
column(vplotOutput("plot", width = "775px", height = "775px"),
width = 8)
)
)
server <- function(input, output) {
dat <- function(num){
x <- replicate(2, runif(num ,min = -1, max = 1))
inside <- (apply(x, 1, function(x) {x[1]^2 +x[2]^2}))<=1
data.frame(x, inside)
}
rv <- reactive({dat(input$num)})
output$pi <- renderPrint({
4 *sum(rv()$inside)/input$num
})
output$plot <- renderPlot({
qplot(rv()[,1], rv()[,2], data = rv(),color = inside, xlab = "x", ylab = "y") +
#scale_colour_manual(values=c("#9999CC", "#66CC99")) +
scale_color_brewer(palette = "Set1") +
theme_minimal() +
theme(legend.position="none")
})
}
shinyApp(ui = ui, server = server)
library(ggplot2)
library(shiny)
library(shinythemes)
ui <- fluidPage( theme = shinytheme("flatly"),
fluidRow( column (verticalLayout(
helpText("We will aproximate Pi by generating random points
in a square and then counting what fraction of those
points are inside the circle contained in the square.
You can think of this as randomly throwing darts at a square board.
Since we know what the area of a square is we've
replaced a calculus problem with a counting problem! Play around with the slider on the
right - you should get a better approximation of Pi the more points you use."),
wellPanel(sliderInput(inputId = "num",
label = "Number of Points",
value = 100, min = 10, max = 30000)),
wellPanel("Your approximation of pi is:",
verbatimTextOutput("pi"))) , width = 3, offset = 1),
column(plotOutput("plot", width = "775px", height = "775px"),
width = 8)
)
)
server <- function(input, output) {
dat <- function(num){
x <- replicate(2, runif(num ,min = -1, max = 1))
inside <- (apply(x, 1, function(x) {x[1]^2 +x[2]^2}))<=1
data.frame(x, inside)
}
rv <- reactive({dat(input$num)})
output$pi <- renderPrint({
4 *sum(rv()$inside)/input$num
})
output$plot <- renderPlot({
qplot(rv()[,1], rv()[,2], data = rv(),color = inside, xlab = "x", ylab = "y") +
#scale_colour_manual(values=c("#9999CC", "#66CC99")) +
scale_color_brewer(palette = "Set1") +
theme_minimal() +
theme(legend.position="none")
})
}
shinyApp(ui = ui, server = server)
?wellPanel
ui <- fluidPage( theme = shinytheme("flatly"),
fluidRow( column (verticalLayout(
wellPanel("We will aproximate Pi by generating random points
in a square and then counting what fraction of those
points are inside the circle contained in the square.
You can think of this as randomly throwing darts at a square board.
Since we know what the area of a square is we've
replaced a calculus problem with a counting problem! Play around with the slider on the
right - you should get a better approximation of Pi the more points you use."),
wellPanel(sliderInput(inputId = "num",
label = "Number of Points",
value = 100, min = 10, max = 30000)),
wellPanel("Your approximation of pi is:",
verbatimTextOutput("pi"))) , width = 3, offset = 1),
column(plotOutput("plot", width = "775px", height = "775px"),
width = 8)
)
)
server <- function(input, output) {
dat <- function(num){
x <- replicate(2, runif(num ,min = -1, max = 1))
inside <- (apply(x, 1, function(x) {x[1]^2 +x[2]^2}))<=1
data.frame(x, inside)
}
rv <- reactive({dat(input$num)})
output$pi <- renderPrint({
4 *sum(rv()$inside)/input$num
})
output$plot <- renderPlot({
qplot(rv()[,1], rv()[,2], data = rv(),color = inside, xlab = "x", ylab = "y") +
#scale_colour_manual(values=c("#9999CC", "#66CC99")) +
scale_color_brewer(palette = "Set1") +
theme_minimal() +
theme(legend.position="none")
})
}
shinyApp(ui = ui, server = server)
ui <- fluidPage( theme = shinytheme("cosmo"),
fluidRow( column (verticalLayout(
wellPanel("We will aproximate Pi by generating random points
in a square and then counting what fraction of those
points are inside the circle contained in the square.
You can think of this as randomly throwing darts at a square board.
Since we know what the area of a square is we've
replaced a calculus problem with a counting problem! Play around with the slider on the
right - you should get a better approximation of Pi the more points you use."),
wellPanel(sliderInput(inputId = "num",
label = "Number of Points",
value = 100, min = 10, max = 30000)),
wellPanel("Your approximation of pi is:",
verbatimTextOutput("pi"))) , width = 3, offset = 1),
column(plotOutput("plot", width = "775px", height = "775px"),
width = 8)
)
)
server <- function(input, output) {
dat <- function(num){
x <- replicate(2, runif(num ,min = -1, max = 1))
inside <- (apply(x, 1, function(x) {x[1]^2 +x[2]^2}))<=1
data.frame(x, inside)
}
rv <- reactive({dat(input$num)})
output$pi <- renderPrint({
4 *sum(rv()$inside)/input$num
})
output$plot <- renderPlot({
qplot(rv()[,1], rv()[,2], data = rv(),color = inside, xlab = "x", ylab = "y") +
#scale_colour_manual(values=c("#9999CC", "#66CC99")) +
scale_color_brewer(palette = "Set1") +
theme_minimal() +
theme(legend.position="none")
})
}
shinyApp(ui = ui, server = server)
library(ggplot2)
library(shiny)
library(shinythemes)
ui <- fluidPage( theme = shinytheme("spacelab"),
fluidRow( column (verticalLayout(
wellPanel("We will aproximate Pi by generating random points
in a square and then counting what fraction of those
points are inside the circle contained in the square.
You can think of this as randomly throwing darts at a square board.
Since we know what the area of a square is we've
replaced a calculus problem with a counting problem! Play around with the slider on the
right - you should get a better approximation of Pi the more points you use."),
wellPanel(sliderInput(inputId = "num",
label = "Number of Points",
value = 1000, min = 10, max = 30000)),
wellPanel("Your approximation of pi is:",
verbatimTextOutput("pi"))) , width = 3, offset = 1),
column(plotOutput("plot", width = "775px", height = "775px"),
width = 8)
)
)
server <- function(input, output) {
dat <- function(num){
x <- replicate(2, runif(num ,min = -1, max = 1))
inside <- (apply(x, 1, function(x) {x[1]^2 +x[2]^2}))<=1
data.frame(x, inside)
}
rv <- reactive({dat(input$num)})
output$pi <- renderPrint({
4 *sum(rv()$inside)/input$num
})
output$plot <- renderPlot({
qplot(rv()[,1], rv()[,2], data = rv(),color = inside, xlab = "x", ylab = "y") +
#scale_colour_manual(values=c("#9999CC", "#66CC99")) +
scale_color_brewer(palette = "Set1") +
theme_minimal() +
theme(legend.position="none")
})
}
shinyApp(ui = ui, server = server)
ui <- fluidPage( theme = shinytheme("united"),
fluidRow( column (verticalLayout(
wellPanel("We will aproximate Pi by generating random points
in a square and then counting what fraction of those
points are inside the circle contained in the square.
You can think of this as randomly throwing darts at a square board.
Since we know what the area of a square is we've
replaced a calculus problem with a counting problem! Play around with the slider on the
right - you should get a better approximation of Pi the more points you use."),
wellPanel(sliderInput(inputId = "num",
label = "Number of Points",
value = 1000, min = 10, max = 30000)),
wellPanel("Your approximation of pi is:",
verbatimTextOutput("pi"))) , width = 3, offset = 1),
column(plotOutput("plot", width = "775px", height = "775px"),
width = 8)
)
)
server <- function(input, output) {
dat <- function(num){
x <- replicate(2, runif(num ,min = -1, max = 1))
inside <- (apply(x, 1, function(x) {x[1]^2 +x[2]^2}))<=1
data.frame(x, inside)
}
rv <- reactive({dat(input$num)})
output$pi <- renderPrint({
4 *sum(rv()$inside)/input$num
})
output$plot <- renderPlot({
qplot(rv()[,1], rv()[,2], data = rv(),color = inside, xlab = "x", ylab = "y") +
#scale_colour_manual(values=c("#9999CC", "#66CC99")) +
scale_color_brewer(palette = "Set1") +
theme_minimal() +
theme(legend.position="none")
})
}
shinyApp(ui = ui, server = server)
library(ggplot2)
library(shiny)
library(shinythemes)
ui <- fluidPage( theme = shinytheme("flatly"),
fluidRow( column (verticalLayout(
wellPanel("We will aproximate Pi by generating random points
in a square and then counting what fraction of those
points are inside the circle contained in the square.
You can think of this as randomly throwing darts at a square board.
Since we know what the area of a square is we've
replaced a calculus problem with a counting problem! Play around with the slider on the
right - you should get a better approximation of Pi the more points you use."),
wellPanel(sliderInput(inputId = "num",
label = "Number of Points",
value = 1000, min = 10, max = 30000)),
wellPanel("Your approximation of pi is:",
verbatimTextOutput("pi"))) , width = 3, offset = 1),
column(plotOutput("plot", width = "775px", height = "775px"),
width = 8)
)
)
server <- function(input, output) {
dat <- function(num){
x <- replicate(2, runif(num ,min = -1, max = 1))
inside <- (apply(x, 1, function(x) {x[1]^2 +x[2]^2}))<=1
data.frame(x, inside)
}
rv <- reactive({dat(input$num)})
output$pi <- renderPrint({
4 *sum(rv()$inside)/input$num
})
output$plot <- renderPlot({
qplot(rv()[,1], rv()[,2], data = rv(),color = inside, xlab = "x", ylab = "y") +
#scale_colour_manual(values=c("#9999CC", "#66CC99")) +
scale_color_brewer(palette = "Set1") +
theme_minimal() +
theme(legend.position="none")
})
}
shinyApp(ui = ui, server = server)
?"shinytheme"
?rsconnect
ui <- fluidPage( theme = shinytheme("flatly"),
fluidRow( column (verticalLayout(
wellPanel("We will aproximate Pi by generating random points
in a square and then counting what fraction of those
points are inside the circle contained in the square.
You can think of this as randomly throwing darts at a square board.
Since we know what the area of a square is we've
replaced a calculus problem with a counting problem! Play around with the slider on the
right - you should get a better approximation of Pi the more points you use."),
wellPanel(sliderInput(inputId = "num",
label = "Number of Points",
value = 1000, min = 10, max = 30000)),
wellPanel("Your approximation of pi is:",
verbatimTextOutput("pi"))) , width = 3, offset = 1),
column(plotOutput("plot", width = "775px", height = "775px"),
width = 8)
)
)
server <- function(input, output) {
dat <- function(num){
x <- replicate(2, runif(num ,min = -1, max = 1))
inside <- (apply(x, 1, function(x) {x[1]^2 +x[2]^2}))<=1
data.frame(x, inside)
}
rv <- reactive({dat(input$num)})
output$pi <- renderPrint({
4 *sum(rv()$inside)/input$num
})
output$plot <- renderPlot({
qplot(rv()[,1], rv()[,2], data = rv(),color = inside, xlab = "x", ylab = "y") +
#scale_colour_manual(values=c("#9999CC", "#66CC99")) +
scale_color_brewer(palette = "Set1") +
theme_minimal() +
theme(legend.position="none")
})
}
shinyApp(ui = ui, server = server)
library(shiny)
library(babynames)
library(data.table)
library(streamgraph)
library(dygraphs)
library(tidyr)
ui <- fluidPage(
titlePanel("Baby Name Explorer"),
sidebarLayout(
sidebarPanel( helpText("Pick up to five names below and explore their popularity as baby names over time:"),
textInput(inputId = "name1", " ", value = "Judy"),
textInput(inputId = "name2", " ", value = "Emma"),
textInput(inputId = "name3", " ", value = "Samantha"),
textInput(inputId = "name4", " "),
textInput(inputId = "name5", " "),
radioButtons(inputId = "sex",label = "",
choices = c( "Female" = "F", "Male" = "M")),
width = 2),
mainPanel(dygraphOutput("plot2", width = "1100px", height = "600px"),
streamgraphOutput("plot1")
)
)
)
server <- function(input, output) {
#data <- reactive({
#
#   data.table(babynames)[name %in% c(input$name1, input$name2, input$name3,input$name4,
#                                        input$name5)][sex %in% input$sex][year >=1930]
#   })
#observeEvent(input$type,
#output$plot1 <- renderStreamgraph({
#    data.table(babynames)[name %in% c(input$name1, input$name2, input$name3,input$name4,
#                                      input$name5)][sex %in% input$sex][,prop := NULL][,sex := NULL][year > 1910] %>%
#    streamgraph(name, n, year) %>%
#    sg_fill_brewer("Set1")
#})
#)
output$plot2 <- renderDygraph({
data.table(babynames)[name %in% c(input$name1, input$name2, input$name3,input$name4,
input$name5)][sex %in% input$sex][,prop := NULL][,sex := NULL][year > 1910] %>%
spread(key = name, value = n) %>%
dygraph() %>%
dyAxis("y",label = "Baby Count", labelWidth = 14 ) %>%
dyAxis("x", drawGrid = FALSE , label = "Year of Birth", labelHeight = 14) %>%
dyOptions(axisLineWidth = .5, strokeWidth = 1.5, axisTickSize = 10,
axisLabelFontSize = 12, gridLineColor = "lightgrey",
axisLabelColor = "grey", axisLineColor = "grey",
colors = RColorBrewer::brewer.pal(5, "Dark2"))
})
}
shinyApp(ui = ui, server = server)
shiny::runApp()
